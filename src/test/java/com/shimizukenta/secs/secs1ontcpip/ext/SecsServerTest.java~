package com.shimizukenta.secs.secs1ontcpip.ext;

import com.shimizukenta.secs.SecsMessage;
import com.shimizukenta.secs.hsmsss.HsmsSsCommunicator;
import com.shimizukenta.secs.hsmsss.HsmsSsCommunicatorConfig;
import com.shimizukenta.secs.secs2.Secs2;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.util.Arrays;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.HashMap;
import java.util.Map;

/**
 * SecsServer 测试类
 * 测试 HSMS-SS 模式和传统 SECS-I 模式
 */
public class SecsServerTest {

    private static final int PORT = 5000;
    private static final int TIMEOUT = 10000; // 10秒超时
    private static final int MAX_CONNECTIONS = 5;

    // 保存客户端ID和地址的映射关系
    private final Map<Integer, String> clientAddresses = new HashMap<>();

    private SecsServer server;

    @Before
    public void setup() {
        // 测试前准备
    }

    @After
    public void cleanup() {
        // 测试后清理
        if (server != null) {
            server.stop();
        }
    }

    /**
     * 测试 SECS-I 模式服务器
     */
    @Test
    public void testSecsIMode() {
        try {
            // 创建 SECS-I 模式服务器
            server = new SecsServer(PORT, MAX_CONNECTIONS, TIMEOUT, false);

            // 设置消息处理器
            server.setMessageHandler((clientId, stream, function, systemBytes, data) -> {
                String clientAddress = clientAddresses.getOrDefault(clientId, "unknown");
                System.out.println("收到 SECS-I 消息: 客户端=" + clientAddress + ", S" + stream + "F" + function);
                System.out.println("系统字节: " + bytesToHexString(systemBytes));
                if (data != null) {
                    System.out.println("数据长度: " + data.length);
                }

                // 处理特定消息 - 例如对 S1F13 返回 S1F14
                if (stream == 1 && function == 13) {
                    // 构建回复消息
                    byte[] replyData = {0x01, 0x02, 0x03, 0x04}; // 示例数据
                    server.sendMessage(clientId, 1, 14, systemBytes, replyData);
                }
            });

            // 设置连接事件监听器
            server.setConnectionEventListener(new SecsServer.ConnectionEventListener() {
                @Override
                public void onClientConnected(int clientId, String address) {
                    System.out.println("客户端连接: ID=" + clientId + ", 地址=" + address);
                    // 保存客户端地址信息以便后续使用
                    clientAddresses.put(clientId, address);
                }

                @Override
                public void onClientDisconnected(int clientId) {
                    System.out.println("客户端断开连接: ID=" + clientId + ", 地址=" + clientAddresses.getOrDefault(clientId, "unknown"));
                    clientAddresses.remove(clientId);
                }
            });

            // 启动服务器
            server.start();
            System.out.println("SECS-I 服务器已启动，端口: " + PORT);

            // 等待一段时间以观察连接（在实际测试中可能会使用客户端进行连接）
            Thread.sleep(10000);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 测试 HSMS-SS 模式服务器
     */
    @Test
    public void testHsmsMode() {
        try {
            // 创建 HSMS-SS 模式服务器
            server = new SecsServer(PORT, MAX_CONNECTIONS, TIMEOUT, true);

            final AtomicBoolean messageReceived = new AtomicBoolean(false);

            // 设置消息处理器
            server.setMessageHandler((clientId, stream, function, systemBytes, data) -> {
                String clientAddress = clientAddresses.getOrDefault(clientId, "unknown");
                System.out.println("收到 HSMS-SS 消息: 客户端=" + clientAddress + ", S" + stream + "F" + function);
                System.out.println("系统字节: " + bytesToHexString(systemBytes));
                if (data != null) {
                    System.out.println("数据长度: " + data.length);
                }

                messageReceived.set(true);

                // 处理特定消息 - 例如对 S1F13 返回 S1F14
                if (stream == 1 && function == 13) {
                    // 构建回复消息
                    byte[] replyData = {0x01, 0x02, 0x03, 0x04}; // 示例数据
                    server.sendMessage(clientId, 1, 14, systemBytes, replyData);
                }
            });

            // 设置连接事件监听器
            server.setConnectionEventListener(new SecsServer.ConnectionEventListener() {
                @Override
                public void onClientConnected(int clientId, String address) {
                    System.out.println("客户端连接: ID=" + clientId + ", 地址=" + address);
                    // 保存客户端地址信息以便后续使用
                    clientAddresses.put(clientId, address);
                }

                @Override
                public void onClientDisconnected(int clientId) {
                    System.out.println("客户端断开连接: ID=" + clientId + ", 地址=" + clientAddresses.getOrDefault(clientId, "unknown"));
                    clientAddresses.remove(clientId);
                }
            });

            // 启动服务器
            server.start();
            System.out.println("HSMS-SS 服务器已启动，端口: " + PORT);

            // 等待一段时间以让服务器完全启动
            Thread.sleep(2000);

            // 创建并连接HSMS-SS客户端（作为测试）
            connectTestHsmsClient();

            // 等待消息接收
            int maxWaitTime = 10000; // 最多等待10秒
            int waitInterval = 500; // 每次等待0.5秒
            int totalWaitTime = 0;

            while (!messageReceived.get() && totalWaitTime < maxWaitTime) {
                Thread.sleep(waitInterval);
                totalWaitTime += waitInterval;
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 连接测试HSMS-SS客户端
     */
    private void connectTestHsmsClient() throws IOException, InterruptedException {
        // 创建HSMS-SS客户端配置
        HsmsSsCommunicatorConfig config = new HsmsSsCommunicatorConfig();
        config.socketAddress(new InetSocketAddress("localhost", PORT));
        
        // 创建客户端通信器
        HsmsSsCommunicator client = HsmsSsCommunicator.newInstance(config);
        
        // 打开连接
        client.open();
        
        // 等待连接建立
        Thread.sleep(2000);
        
        if (client.isOpen()) {
            System.out.println("HSMS-SS客户端已连接");
            
            // 发送测试消息 (S1F13 - 获取设备状态)
            try {
                Secs2 data = Secs2.binary(new byte[]{0x01});
                boolean wBit = true; // 需要回复
                
                SecsMessage reply = client.send(1, 13, wBit, data).orElse(null);
                
                if (reply != null) {
                    System.out.println("收到回复: S" + reply.getStream() + "F" + reply.getFunction());
                    System.out.println("回复数据: " + reply.secs2());
                } else {
                    System.out.println("没有收到回复");
                }
            } catch (Exception e) {
                System.out.println("发送消息时出错: " + e.getMessage());
            }
            
            // 关闭客户端
            client.close();
        } else {
            System.out.println("HSMS-SS客户端连接失败");
        }
    }

    /**
     * 将字节数组转换为十六进制字符串
     */
    private static String bytesToHexString(byte[] bytes) {
        if (bytes == null) {
            return "null";
        }
        
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02X ", b));
        }
        return sb.toString();
    }
}
